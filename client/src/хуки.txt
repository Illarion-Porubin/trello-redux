Хуки - это функциональность, которая позволяет использовать состояния без использования классов.
Хуки нужны, чтобы обновлять состояние.

useState хранить состояние внутреннего компонента, это состояние хранится между ререндерамиб
сам useState содержит текущее состояние и функцию которое это состояние изменяет

useEffect в общем случае применяется для сайт эффектов, побочных функций которые должны выполнятся на изменение пропсов либо состояний.
Это может быть запрос к серверу, установка таймеров, интервалов, инициализация подписок и т.д
Вторым аргументом useEffect принимает либо пропсы, либо стеты которые нужно отслеживать

useContext - предназначен для чтения значений контехта, контехт это данные, которые видны на протяжении всего дерева компонентов,
контехт позволяет передавать данные через дерево компонентов напрямую, то есть не нужно передавать пропс от родителя дочернему компоненту, а от него ещё к дочернему


useReducer используется как альтернатива для use state, особенно если есть сложная логика.
useReducer использует тот же подход что и redux: state, action, dispath. Внутри useReducer есть
функция reducer, в которую передается action и изменяется состояние

useCallback возвращает мемомизированую версию функции, которая изменяется только если изменяется
значение одной из зависимостей. Мемоизированя - помогает избежать ненужный ререндер дочерних компонентов которые полагаются на равенство ссылок, то есть при создании чистого компонента который полагается на равенство ссылок проперти,
то есть если проперти будет иметь туже самую ссылку при следующих ререндерах,
дочерний компонент ререндерится не будет.

Компонент высшего порядка memo - используется для того, чтобы указать что компонент полагается на равенство ссылок

useMemo - возвращает мемомизированые значения функции, например в приложении используется какая-то функция которая делает
дорогостоящее вычисления, чтобы не делать эти вычисления на каждый ререндер и не запускать функцию снова, можно использовать

хук useMemo будет проводить вычисления только тогда когда значения внутри вычисляемой функции будут меняться и в этом случае
будет возвращено сохраненное мемомезированнное значение

useRef нужен для того, чтобы хранить одно и то же значение, которое будет постоянным
в течении всего жизненного цикла, то есть которое не будет менятся после каждого ререндера,
useRef обычно используется чтобы явно обратиться к дочернему компоненту и вызвать его функции
useRef также может хранить любое значение необязательно ссылку на элемент, useRef возвращает
объект с результатом поля карент и изменение поля карент не приводит к ререндерингу компонента

useImperativeHandle он кастомизирует значения к которым может обратиться родительский компонент
при помощи ref

useLayoutEffect похож на useEffect, они отличаются тем, что вызываются на разных этапах жизненного цикла компонента и useLayoutEffect работает в синхронном режиме, он вызывается до useEffect,
то есть если в useLayoutEffect положить долго вычисляемую задачу, она будет блокировать рендер
до тех пор, пока useLayoutEffect не будет выполнен

custom hooks - в него инкапсулируется некая логика которая работает с состояниями
в отдельный хук, это нужно для того чтобы переиспользовать этот хук, эту работу с состояниями в других компонентах

useDebugValue используется для того, чтобы в консоли разработчика react-devtools видеть значения которые удобно воспринимать и
проводить дебаги кастомных хуков